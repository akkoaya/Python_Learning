
## 有序的组:`序列`
类型有:`字符串`、`列表类型`、`元组类型`
>具有先后顺序，元素可以相同，元素类型可以不同，元素间由序号引导，可通过`下标`访问特定元素，支持`索引`和`切片`操作
- 字符串类型: `str`。''(用引号表示)
- 列表类型：`list`。[](用方括号表示)
- 元组类型：`tuple`。()(用圆括号表示)
> 字符串与元组的元素是不可变的，列表是可变的
## 无序的组
`集合(set)`和`字典(dict)`
> 它们存储的数据都是无序的，每份元素占用不同的内存
- 集合类型：set。{}(用花括号表示)
- 字典类型：dict。{}(用花括号表示)



## 组的运算
>无序组：集合和字典**不支持**`索引`、`切片`、`相加`、`相乘`操作 
>
> 但无序组能使用`减号-`来求差集
> 
> `&`号用于求两个集合的交集
> 
> `|`号用于求两个集合的并集

>有序组，即字符串，列表和元组，**不支持**使用`减号-`，来求两段集合的差集;`&`和`|`号也不能使用
>
>但有序组支持`索引`、`切片`、`相加`、`相乘`操作 



## 序列的运算
>包括：`连接运算`、`重复运算`、`成员运算`、`切片运算`、`格式化运算`等

1.**连接运算**：用`+`表示，可以连接任意数据类型，包括字符串

    'hello'+' world'----->hello world

2.**重复运算**：用`*`表示，可以重复任意数据类型，包括字符串

    'hello '*3----->'hello hello hello' 
    #但是不能 'hello'*3.5 或者 'hello'*'world'

3.**成员运算**：用`in`表示，判断某个序列是否是一个序列的子序列

    'hello' in 'hello world'------>True(意为'hello'是否在'hello world'中)
    'sun' in 'hello world'------>False
    'hello' not in 'hello world'------>False(意为'hello'是否不在'hello world'中)

4.**切片运算**：用`[]`表示，可以截取字符串

左闭右开原则

    'hello world'[0]----->'h' (记得是从0开始)
    'hello world'[1]----->'e'
    'hello world'[-1]----->'d'

    'hello world'[0:5]----->'hello' (不是[0:4])-----意为选取前五个字符
    'hello world'[0:-2]----->'hello wor' -----------意为不选取后两个字符
### 提问：用两种方式获取`world`

(1).正向获取

    'hello world'[6:11]----->'world'
    #空格也算一个字符(如果有很多的字符，正向获取就显得效率低下了)

(2).反向获取

    'hello world'[6: ]----->'world'
    #多数会用这种方式截取(意为截取从第6个字符开始到最后的所有字符)

    例如：'python php c++ javascript ruby',要截取ruby
    'python php c++ javascript ruby'[-4:]----->'ruby'
    'python php c++ javascript ruby'[:-4]----->'python php c++ javascript '-----相当于[0:-4]

### 思考:'hello world'[0:8:2]----->'hlow'
解答：第三个参数表示步长

5.**计数运算**：用`len()`表示，可以计算任意数据类型中某个元素出现的次数

    len('hello world')----->11
    len([1,2,3,4])----->4

6.**最值运算**：用`max()`和`min()`表示，可以计算任意数据类型中元素的最大值和最小值

    max('hello world')----->'w'
    #如果是字符串，则取英文字母表靠后的一个字符
    min('hello world')----->' '
    #输出了空格，这是根据ASCII码来排序的，空格的ASCII码是32，比'd'的ASCII码100小
查看ASCII码的方法:`ord()函数`

    ord('d')------>100
    ord(' ')------>32

7.**判断运算**：用`if`表示，可以判断任意数据类型

    if 'hello' in 'hello world'------>True

8.**比较运算**：用`>`、`<`、`==`、`!=`表示，可以比较任意数据类型

    'hello'=='hello'------>True
    'hello'=='world'------>False
    'hello'!='hello'------>False
    'hello'!='world'------>True

9.**格式化运算**：用`.format()`表示，可以格式化序列


## 列表类型详解
动态语言的特点：可以动态添加元素，添加不同数据类型到列表中,不用像静态语言一样只能用一种数据类型

    type([1,2,3,4,5])----->list
    type(['hello','world',1,2,True，False])----->list
    type([[1,2],['h','w'],[False,True]])----->list
    #二维数组(python中叫“嵌套列表”)

`索引`、`切片`、`相加`、`相乘`操作

    ['A','B','C','D'][0]----->'A'--------得到的是字符串
    ['A','B','C','D'][1]----->'B'
    ['A','B','C','D'][0:2]----->['A','B']--------得到的还是列表
    ['A','B','C','D'][-1:]----->['D']
    ['A','B','C','D']+['一','二']----->['A','B','C','D','一','二']
    ['A','B','C','D']*2----->['A','B','C','D','A','B','C','D']


## 元组类型详解
    type((1,2,3,4,5))----->tuple
    type(('hello','world',1,2,True，False))----->tuple(元组中的元素不能被修改，但是可以被索引)
    type(([1,2],['h','w'],[False,True]))----->tuple

`索引`、`切片`、`相加`、`相乘`操作

    (1,2,3,4,5)[0]----->1
    (1,2,3,4,5)[-1]----->5
    (1,2,3,4,5)[1:3]----->(2,3)
    (1,2,3,4,5)+(1,2)----->(1,2,3,4,5,1,2)
    (1,2,3,4,5)*2----->(1,2,3,4,5,1,2,3,4,5)

### 思考:

    >>> type((1,2,3))
    <class 'tuple'>

    >>> type([1,2,3])
    <class 'list'>

    >>> type('1,2,3')
    <class 'str'>

    但是>>> type((1))
    <class 'int'>
    #因为在idle中((1))如果只有一个元素，那里面的括号被认为是数学运算，不被认为是元组符号

    #如果要让type识别为元组，要假装后面还有其他元组
    >>> type((1,))
    <class 'tuple'>

    #但是一个int元素的列表不会被识别为int
    >>> type([1])
    <class 'list'>
    #因为list的符号[]不会被当作数学运算

    空元组：type(())
    <class 'tuple'>

## 列表和元组的区别:
>1.列表是动态的，属于可变序列，它的元素可以随时增加、修改或者删除;而元组是静态的，属于不可变序列，无法增加、删除、修改元素，除非整体替换。

>2.列表可以使用`append()`、`extend()`、`insert()`、`remove()`和`pop()`等方法实现添加和修改列表元素;而元组则不行，因为不能向元组中添加和修改元素。同样，也不能删除元素，但可以整体替换。

>3.列表可以使用切片访问和修改列表中的元素;元组也支持切片，但是它只支持通过切片访问元组中的元素，不支持修改。

>4.元组比列表的访问和处理速度快。所以如果只需要对其中的元素进行访问，而不进行任何修改，建议使用元组而不使用列表。(这是元组的优点1)

>5.因为列表可以修改，元组不可以修改，因此元组比列表具有更高的安全性。(这是元组的优点2)

>6.列表不能作为字典的键，而元组可以。----为什么？(这是元组的优点3)
>
>答：因为元组是不可变的，而列表是可变的。 python中要求字典中的键是不可变的，如字符串、数字或元组，而值则可以取任何数据类型。

>7.存储方式不同：空列表比空元组多占用16个字节。(这是元组的优点4-----但仍要记住，如果需要可改变的组，只能使用list、dict、set，其他情况，能用元组就用元组)


## 集合类型详解
    type(set())----->set
    #这才是定义空集合的方法
    type({'hello','world','1','2','3'})----->set
    type({1,2,3,4,5,6})----->set
重复的元素会被自动过滤

    {'1','2','3','4','1','2','2'}----->{'1','2','3','4'}
可以使用`-`求差集

    {'1','2','3','4','5','6'}-{'1','2','3'}----->{'4','5','6'}
可以使用`&`求交集

    {'1','2','3','4','5','6'}&{'1','2','3'}----->{'1','2','3'}
可以使用`|`求并集

    {'1','2','3','4','5','6'}|{'1','7','8'}----->{'1','2','3','4','5','6','7','8'}


## 字典类型详解
    type({})----->dict
    #空集合是字典类型
dict有两个部分:`Key`和`Value`。最常用的功能是通过Key来寻找Value
`{Key1:Value1,Key2:Value2,Key3:Value3.....}`的格式被称为`dict`  
*Key的值不能重复，否则后面的会覆盖前面的*  
`{'1':'hello',1:'world'}`不会被覆盖，因为数字1和字符串1是不同的

    type({'1':'hello','2':'world','3':'!'})----->dict
    type({'1':'hello','2':{4:'4'},'3':'!'})----->dict-------字典里可以嵌套字典
通过key来寻找value

    {'1':'hello','2':'world','3':'!'}['1']----->'hello'

    {[1,2]:'hello','2':'world','3':'!'}----->报错
    而{(1,2):'hello','2':'world','3':'!'}-----不会报错，原因是不可变的数据类型才能作为Key
